<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Client</title>
</head>
<body>
    <div class="canvas-holder" style="background-color: gray;">
        <canvas width="600" height="300" id="StatisticCanva">
            
        </canvas>
    </div>

    <button id="StartListening">Start Listening</button>
    <button id="StopListening">Stop Listening</button>
    
    <label for="FetchChunkData">Keep updating</label>
    <input type="checkbox" name="" id="FetchChunkData">
    <!-- <button id="FetchChunkData">Fetch data</button> -->
    <script>
        const ListenButton = document.getElementById("StartListening");
        const StopListenButton = document.getElementById("StopListening");
        const FetchCheckbox = document.getElementById("FetchChunkData");
        ListenButton.onclick=start_listening;
        StopListenButton.onclick=stop_listening;

        const Canvas = document.getElementById("StatisticCanva");
        const SEISMIC_GRADIENT = [
            [0, 0, 85],
            [0, 0, 255],
            [255, 255, 255],
            [255, 7, 7],
            [170, 0, 0],
        ];
        const intervalId = setInterval(() => {
            if (!FetchCheckbox.checked) {
                return;
            }
            fetch_chunk_data()
        }, 100); // Executes every 1 second


        function start_listening() {
            fetch("http://127.0.0.1:5000/listen", {
                method: 'GET',
                headers: {
                }
            }).then(
            response => {
                return response.json()
            }
            ).then(data => {console.log(data)}).catch(error => {
                console.error('Error fetching data:', error); 
            });
        }

        function stop_listening() {
            fetch("http://127.0.0.1:5000/stop-listening", {
                method: 'GET',
                headers: {

                }
            }).then(
                response => {
                    console.log(response)
                    return response.json()
                }
            ).then(data => {
                // console.log(data)
                parse_chunk_data(data.body)
            }).catch(error => {
                console.error('Error fetching data:', error); 
            });
        }

        function fetch_chunk_data() {
            fetch("http://127.0.0.1:5000/get-data", {
                method: 'GET',
                headers: {

                }
            }).then(
                response => {
                    // console.log(response)
                    return response.json()
                }
            ).then(data => {
                // console.log(data)
                parse_chunk_data(data.body)

            }).catch(error => {
                console.error('Error fetching data:', error); 
            });
        }

        
        function parse_chunk_data(body) {
            context = Canvas.getContext("2d");
            pixel_size = 6
            let gradient = SEISMIC_GRADIENT

            Canvas.setAttribute("width", body.grid_size[0] * pixel_size);
            Canvas.setAttribute("height", body.grid_size[1] * pixel_size);
            
            context.fillStyle = 'rgba('+gradient[0][0] + ',' + gradient[0][1] + ',' + gradient[0][2] +','+ 1 + ')';
            context.fillRect(0, 0, Canvas.width, Canvas.height);

            let chunk_data = body.chunk_data.chunks;

            for (const row_key in chunk_data) {
                for (let idx = 0; idx < chunk_data[row_key].length; idx++) {
                    // console.log("Painting " + row_key + " " + idx)
                    let value = chunk_data[row_key][idx];
                    if (value == 0) {
                        continue;
                    }
                    let color_rgb = interpolate_between_gradient(gradient, value);
                    let color = 'rgba('+color_rgb[0] + ',' + color_rgb[1] + ',' + color_rgb[2] +','+ 1 + ')';
                    drawDot(context, idx, row_key, color, pixel_size);
                }
            }
        }

        function interpolate_between_gradient(gradient, delta) {
            let total_delta = delta * gradient.length;
            let start_idx = Math.max(Math.floor((gradient.length * delta) - 1), 0)
            let rgb = gradient[start_idx];
            for (let idx = start_idx; idx < gradient.length; idx++) {
                rgb = rgb_interpolate(
                    rgb[0], rgb[1], rgb[2],
                    gradient[idx][0], gradient[idx][1], gradient[idx][2],
                    total_delta
                )
                total_delta = Math.max(total_delta - idx, 0)
            }

            return rgb
        }

        function rgb_interpolate(r, g, b, r1, g1, b1, delta) {
            new_r = r + (r1 - r) * delta;
            new_g = g + (g1 - g) * delta;
            new_b = b + (b1 - b) * delta;

            return [new_r, new_g, new_b]
        }

        function drawDot(context, x, y, color, size = 1) {
            context.fillStyle = color;
            context.fillRect(x * size, y * size, size, size);
        }
    </script>
</body>
</html>